Network Working Group                              M. Emilie and M. Lisa
Request For Comments: XXXX                                         ESIPE
STD: XX                                                       April 2020
Obsoletes: None


                    THE CHATHACK PROTOCOL (REVISION 1)
                     
Status of this Memo
    
    This RFC specifies a message and file exchange service protocol for the
    project of Network Programming course in ESIPE and requests discussion and
    suggestions for improvements. Distribution of this memo is limited.
    
Summary

    ChatHack is a protocol used to transfer messages to a group of clients
    and privately and to transfer files and messages between two clients, who 
    will need to be authenticated to use the service. The group exchange will be 
    done through a server, while private exchanges will be done directly between
    clients via TCP connection.

Acknowlegements

    The protocol was originally designed by Carayol Arnaud and Duris Etienne
    as part of the Network Programming course.

1. Purpose

    ChatHack is a protocol which aims to transfer files and messages. It is 
    implemented on top of the Internet Transmission Control Protocol 
    (TCP or socket). [1] It is used to exchange messages and files between 
    several clients. It is designed to be small and easy to implement, therefore
    it lacks most of the features of the secured authentification system we can 
    find on usual chat services.
    
    Two modes of transfer are supported: a client-server-client TCP connexion,
    where multiple clients may exchange simple messages (using UTF-8 encoding)
    and a client-client TCP connexion, where two clients may exchange messages
    (using UTF-8 encoding) and files between them, after asking for a direct 
    connexion through the server.


Marti and Mechouk                                                   [Page 1]

RFC 9692                    PROTOCOL Revision 1                   April 2020

2. Overview of the Protocol
    
    Any transfer begins with a request to connect to a server. This server will
    ask for a login and a password to authenticate the client. If the client
    is not recognised by the server, he will be signed up. The login has to be
    unique for each client. If the server grants the request, the connection is
    opened and the client will be able to start sending and receiving groups
    messages on the ChatHack.
    
    The client is able to receive and send a message through this connexion.
    Each packet contains a message encoded in UTF_8 and will be sent to the
    server. The server will then broadcast it to all connected users. The client
    will also receive all the messages sent by other clients to the server.
    
    A client A may send a request to connect to another client B in order to
    send messages and files privately. This will being with a request to the
    server. The server will ask the client B if it accepts to make the connexion
    and send the response to the client A. If the response is positive, a TCP-
    based connexion will open between the two clients and they will be able to
    communicate between them. Client B may refuse the connection.
    
    This last connection will allow, not only to send messages, but to also send
    files.
    
    Errors cause termination of the connection. An error is signaled by an
    error packet, or by a wrong login, or login password. The server is 
    responsible of closing the connection if there are too many corrupted 
    packets or exceeded timeouts coming from a client.
    
    This protocol is very restrictive, in order to simplify implementation.

Marti and Mechouk                                                   [Page 2]

RFC 9692                    PROTOCOL Revision 1                   April 2020

3. Relation to other Protocols

    ChatHack is designed to be implemented on top of the Tranmission Control
    protocol (TCP). Since socket is implemented on the Internet protocol,
    packets will have an Internet header, a Control header, and a ChatHack
    header. ---- [TODO]

         ---------------------------------------------------------
         |  Local Medium  |  Internet  |  Datagram  |  ChatHack  |
         ---------------------------------------------------------

                      Figure 3-1: Order of Headers

4. Initial Connection Protocol

    An initial connection is established by sending a request to the server and
    receiving a positive reply, which will come with a request for login with or
    without password. Users that have already given an alias and password should
    be known by the server so that their alias cannot be taken or used without
    its associated password, that is to say, giving an alias and a password for
    the first time means that the user is signed up to the ChatHack.
    
    Users that are only logged in without giving a password can choose an alias 
    that is not already taken by an already signed up / logged in user.
    
    As an example, the following steps show how a client can connect to the
    global chat via ChatHack protocol :
    
        1. Client A wants to connect and sends a connexion request to the
        server.
        
        2. The server acknowledges the connexion request and sends a login
        request to the Client A.
        
        3. Client A acknowledges the login request and sends a login with or
        without an associated password.
        
        4. Server acknowledges the login with or without password.
        
    The following steps show how a client can connect to another client in order
    to exchange messages or files privately :
    
        1. Client A sends a private connexion to Client B request to the server.
        
        2. The server transfers the request to Client B.
        
        3. Client B acknowledges the connection request to the server; if it
        refuses the server will return the negative response to Client A.
        
        4. If Client B accepts the private connection request it sends a
        response to the server with its address and the Client A's login.
        
        5. The server redirects this packet to Client A and Client A sends to
        the server a packet with its address and Client B's login.
        
        6. The server redirects this packet to Client B.
        
        7. Client A and Client B have each other's addresses and may open the
        private and direct connection.
         
5. ChatHack Protocol Packets

    ChatHack protocol supports four types of packets, all of which have been
    mentioned above:
    
        Opcode      Operation
        00 - 09     Connection request(CRQ)
        10 - 19     Acknowledgement (ACK)
        20 - 29     Message / file (DATA)
        30 - 39     Error (ERROR)
        
    Opcode is a unique identifier for each type of packet. Since there are
    several packets for each case, we assign a range of codes for each type of
    packet.
    
    The list of packets described below are the following :
        
        Name of packet                      Direction
        Login                               client->server
        Login with Password                 client->server
        Response for login                  server->client
        Response for login and password     server->client
        Group message                       client->server
        Group message broadcast             server->client
        Request for private connection      clientA->server
        Request for private connection      server->clientB
        Response for private connection     clientB->server
        Response for private connection     server->clientA
        Private message/file                clientA->clientB/clientB->clientA
        
    The ChatHack protocol header of a packet contains the opcode associated with
    the packet.
    
5.1. ChatHack Request for Connection Packets

5.1.1. ChatHack Login Packets
    
                       byte       long      String  
                    --------------------------------
                    | Opcode | SizeOfLogin | Login |
                    --------------------------------
                        Figure 5-1 : Login packet
                        
    Login packets have the format shown in Figure 5-1. The opcode associated to
    this type of login packet is 00. The login, corresponding to the alias chosen
    by the client, must be encoded in ASCII in order to allow only a limited set
    of characters in the alias.
    
              byte       long       String        long        String
           ------------------------------------------------------------
           | Opcode | SizeOfLogin | Login | SizeOfPassword | Password |
           ------------------------------------------------------------
                     Figure 5-2 : Login with password packet
    
    Login with password packets have the format shown in Figure 5-2. The opcode
    associated to this type of login is 01. The login and password are encoded
    in ASCII in order to allow a limited set of characters in them.
    
    The Login packets are used as Request for Connection to the server.
    
5.1.2. ChatHack Request for Private Connection Packet
                
    Request for private connection packets have the same format as Login packets,
    as shown in Figure 5-1. The opcode associated to this type of request is 02
    and the field Login corresponds to the alias of the user to whom the client
    wants to be directly connected.
    
    This same packet is used by the server to transmit the request to the client
    to whom the first user wants to be connected to.
                     
5.3. ChatHack Acknowledgment Packets

5.3.1. Chat connection response packets

                   byte       long        String
                ----------------------------------
                | Opcode | SizeOfAckMsg | AckMsg |
                ----------------------------------
                Figure 5-3 : Acknowledgment packet
    
    Simple acknowledgment packet that is sent back to the client to accept the
    connection to the global chat. The server may add a response message.
    
    The return codes of the responses mean:
                
        10. Connection with Log in OK
        11. Connection with Log in and password OK
        12. Connection with Register OK
        
5.3.2. Private connection response packets

           byte     long      String       long        String
        ----------------------------------------------------------
        | Opcode | SizeOfLogin | Login | SizeOfAddress | Address |
        ----------------------------------------------------------
         Figure 5-4 : Positive private connection response packet
                        
    When a private connection request is accepted by a client, it will send an
    acknowledgment packet to the server as shown in the Figure 5-4. The opcode
    is 13 and it contains its address an the login of the requesting client.
    
    The server will redirect this packet to the requesting client. The requesting
    client will send the same packet with its address and the other client's
    login so that both can then open a direct connection between them.
    
                       byte      long    String
                    ----------------------------
                    | Opcode | SizeOfMsg | Msg |
                    ----------------------------
         Figure 5-5 : Negative private connection response packet
                
    If the client refuses the private connexion, a packet with a single opcode
    of 14 will be sent to the requesting client through the server.
        
5.4. ChatHack Data Packets

5.4.1. Global data transmission
 
   byte       long      String        long         String      long      String
--------------------------------------------------------------------------------
| Opcode | SizeOfLogin | Login | SizeOfEncoding | Encoding | SizeOfData | Data |
--------------------------------------------------------------------------------
                   Figure 5-5 : Global chat message packet
                            
    Global chat messages are transferred in DATA packets as shown in the Figure
    5-5. The opcode associated to this data packet is 20. Encoding and login
    fields are encoded in ASCII. Login field corresponds to the sender's alias.
    
    Broadcast of the message by the server is done with the same packet.
    
5.4.2. Private data transmission

            byte       long         String      long       String
        ----------------------------------------------------------
        | Opcode | SizeOfEncoding | Encoding | SizeOfData | Data |
        ----------------------------------------------------------
                    Figure 5-6 : Private message packet
                    
    Private messages are transferred in DATA packets as shown in the Figure 5-6.
    The opcode associated to this data packet is 21. Encoding field must be
    encoded in ASCII.
    
            byte        long         String      long       Bytes
        ----------------------------------------------------------
        | Opcode | SizeOfFileName | FileName | SizeOfData | Data |
        ----------------------------------------------------------
                    Figure 5-7 : Private file data packet
                    
    Files are transferred in DATA packets as shown in the Figure 5-7. The opcode
    associated to this data packet is 22. File name must be encoded in ASCII.
    The encoding of the data is given by the extension after the last "." of the
    file name.
    
    If no valid extension is given, whether it is because the file name does not
    have a clear extension or the extension is not recognised, data packet is
    considered invalid. See error packets below for further information.

5.5. ChatHack Error Packets

                   byte         long          String
                --------------------------------------
                | Opcode | SizeOfErrorMsg | ErrorMsg |
                --------------------------------------
                     Figure 5-8 : ERROR packet
                     
    An ERROR packet (opcodes [30-39]) has the form described in Figure 5-8. An
    ERROR packet can be the aknowledgment of any other type of packet. The 
    opcode is an integer indicating the nature of the error. The error message 
    is used for human understanding and should be in ASCII.
    
    The return codes for the errors mean the following :
        30. Timeout
        31. Login Error
        32. Login with Password Error
        33. Invalid / Corrupted Packet
        34. Invalid File Encoding Error
       
6. Normal Termination

    A termination of the connection is done when a client makes a request and
    this request is accepted without any errors.
    For the sending, the normal termination is when the clientA has sending his
    message to all of the connected client and they all get it whitout any 
    error.
    For a private connection between two clients, the normal termination is when
    the connection between client A and Client B is accepted and the Client B
    receive all of the messages and files from the Client A.

7. Premature Termination

    If a timeout is registered by the server several times by one client, the
    server may close the connection to the client in order to prevent an
    accumulation of unhealthy connections.
    
I. Appendix

Practical examples

1. ChatHack connexion

1.1. Simple Login

    A client wants to connect to the chat with a temporary nickname "Link13". It
    sends a request to the server:
        ---------------------
        | 00 | 6 | "Link13" |
        ---------------------
    The server checks if "Link13" is already taken by a connected or registered
    user. If it is available, the server sends an acceptation response:
        -----------------------------------
        | 10 | 19 | "Welcome to ChatHack" |
        -----------------------------------
    If the nickname is unavailable it sends an error packet:
        ---------------------------------
        | 31 | 17 | "Unavailable Login" |
        ---------------------------------

1.2. Login with Password

    A client wants to connect to the chat with the nickname "Link13" and the
    password "gAn0nD0Rf". It sends a request to the server:
        ---------------------------------------
        | 01 | 6 | "Link13" | 9 | "gAn0nD0Rf" |
        ---------------------------------------
    If the nickname and the password match, the server sends an acceptation
    response:
        -----------------------------------
        | 11 | 19 | "Welcome to ChatHack" |
        -----------------------------------
    If the nickname is available and is not found within already registered
    users, the server registers the user and sends an acceptation response:
        -----------------------------------
        | 12 | 19 | "Welcome to ChatHack" |
        -----------------------------------
    The server checks if "Link13" is already taken by a connected or registered
    user. If the nickname is unavailable it sends an error packet:
        ---------------------------------
        | 31 | 17 | "Unavailable Login" |
        ---------------------------------
    If the alias is found within the registered users but the password does not
    match, the server sends an error packet:
        ------------------------------
        | 32 | 14 | "Wrong password" |
        ------------------------------

1.3 Private connection between two users

    A user with the nickname "Link13" wants to communicate privately to another
    user "SkullKid42". It sends a request to the server:
        --------------------------
        | 02 | 10 | "SkullKid42" |
        --------------------------
    If the user "SkullKid42" is online, the server will simply redirect the same
    packet to it.
    The client may respond positively by sending a packet back to the server
    with its address "Termina".
        -------------------------------------
        | 13 | 6 | "Link13" | 7 | "Termina" |
        -------------------------------------
    The server will redirect the same packet to the user "Link13". This user
    will respond sending his address:
        -----------------------------------------
        | 13 | 10 | "SkullKid42" | 6 | "Hyrule" |
        -----------------------------------------
    This last packet will be redirected by the server to the user "SkullKid42"
    so that both clients get the address and be able to create a direct connection
    between each other.
    
    If the connection is refused by the user "SkullKid42" or it is not connected,
    the server will send a response to the requesting user notifying it:
        ----------------------------------
        | 14 | 18 | "User not connected" |
        ----------------------------------
    If the request does not receive a response within timeout seconds, the
    requesting user gets an error response from the server:
        -------------------------------------
        | 30 | 21 | "client not responding" |
        -------------------------------------
        
2. Data transmission

2.1. ChatHack global chat

    Several users are connected to the ChatHack. The user "SkullKid42" writes a
    message to the server:
        -----------------------------------------------------------------
        | 20 | 10 | "SkullKid42" | 4 | "UTF8" | 16 | "Hello my friends" |
        -----------------------------------------------------------------
    The server broadcasts, that is to say, sends the packet back to all connected
    users, including "SkullKid42" with the same format.
    
    If the packet is wrongly formed, for example, size does not match the actual
    size of the packet or the encoding format is not recognised, the server sends
    an error message to the user and destroys the current data packet:
        ------------------------------
        | 33 | 14 | "Data corrupted" |
        ------------------------------
    
2.2. Private message exchange

    Two clients, "Link13" and "SkullKid42" are directly connected (see section
    1.3) and want to exchange messages:
        -------------------------------------------------------------
        | 21 | 4 | "UTF8" | 32 | "Have you saved the princess yet?" |
        -------------------------------------------------------------

    They may get an error response if the packet is wrongly formed:
        ------------------------------
        | 33 | 14 | "Data corrupted" |
        ------------------------------

2.3. Private file exchange

    Two clients, "Link13" and "SkullKid42" are directly connected (see section
    1.3) and want to exchange a file:
        ------------------------------------------
        | 22 | 15 | "MajorasMask.jpg" | 32 | ... |
        ------------------------------------------
    "..." representing the bytes of the file to be sent.
    
    If the file name does not contain a valid extension, the receiving client
    sends an error packet and the previous packet is automatically destroyed:
        -------------------------------------
        | 34 | 21 | "Cannot recognise file" |
        -------------------------------------
    
Error Codes

    Value   Meaning
    30      Timeout
    31      Login Error
    32      Login with Password Error
    33      Invalid / Corrupted Packet
    34      Invalid File Encoding Error

Marti and Mechouk                                                  [Page 10]

RFC 9692                    PROTOCOL Revision 1                   April 2020


References

    [1] Postel, J., "Transmission Control Protocol", RFC 793, USC/Information
    Sciences Institute, September 1981.


Security Considerations
    
    Since this version of ChatHack protocol does not include per se any form of
    personal data encryption, passwords and logins are transmitted to the network
    in the clear, which is a huge security breach if used alone. Also, ChatHack
    does not allow suppression of personal data saved by the server (such as
    login and password).
    
    There is no more limitations to file transmission other than needing a known
    format of the file. Binaries and executables may be transferred freely so be
    aware of this when implementing this protocol.

Author's Addresses

    Emilie Marti and Lisa Mechouk
    Ecole Supérieure d'Ingénieurs Marne-La-Vallée
    Université Gustave Eiffel
    Boulevard Copernic, 77600 Champs-Sur-Marne
    
    Email: emarti@etud.u-pem.fr and lmechouk@etud.u-pem.fr
